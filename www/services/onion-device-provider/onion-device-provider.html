<link rel="import" href="/lib/polymer/polymer.html">

<dom-module id="onion-device-provider">
	<script>
		'use strict';

		(function () {
			var self = null;

			var created = function () {
				self = this;
			};

			var macResult = null;
			var ipResult = null;
			var rxtxResult = null;

			var ready = function (){
				onionConsole.getService('onion-ubus-provider', function (ubus) {
					self.ubus = ubus;
				});			
			};

			var getMAC = function (callback) {
				var params = {
					device: 'wlan0'
				};
				macResult = callback || self.noop;
				self.ubus.request('iwinfo', 'assoclist', params, setMACResult);
			};

			var setMACResult = function (result) {
				var returnCode = result[0];
				if (returnCode === 0) { 
				    if (result[1] !== null && result[1].results[0] !== null && result[1].results[0].mac !== null) {
				        var mac = result[1].results[0].mac;
				        console.log('MAC[' + mac + ']');
						
						macResult({
							mac: mac
						});
				    } else {
					    macResult({
					    	mac: ''
					    });    
					}
				} else {
				    console.log('Failed to get MAC address!')
					macResult({
						mac: ''
					});
				}
			};

			var getSystem = function (callback) {
				self.ubus.request('system', 'info', {}, callback);
			};

			var getRxTx = function (callback) {
				var params =  {};
				rxtxResult = callback || self.noop;
				self.ubus.request('network.device', 'status', params, setRxTxResult);
			};

			var setRxTxResult = function (result) {
				var returnCode = result[0];
				var receivedkB = 0;
				var transmittedkB = 0;
				
				if (returnCode === 0) {  
				    var rx = result[1].wlan0.statistics.rx_bytes;

                    receivedkB = parseInt(rx);
                    if (receivedkB > 0) {
                        receivedkB = (receivedkB / 1000).toFixed(0);
                    }
                    var tx = result[1].wlan0.statistics.tx_bytes;
                    transmittedkB = parseInt(tx);
                    if (transmittedkB > 0) {
                        transmittedkB = (transmittedkB / 1000).toFixed(0);
                    }

				    console.log('receivedkB[' + receivedkB + ']');
				    console.log('transmittedkB[' + transmittedkB + ']');
	                rxtxResult([{received: receivedkB}, {transmitted: transmittedkB}]);
				} else {
				    console.log('Failed to get received bytes and transmitted bytes!');
                    rxtxResult([{received: ''}, {transmitted: ''}]);
				}
			};
			
			var getIP = function (callback) {
				var params =  {
				    command: 'ifconfig'
				};
				ipResult = callback || self.noop;
				self.ubus.request('file', 'exec', params, setIPResult);
			};
			
			var setIPResult = function (result) {
			    var returnCode = result[0];
			    var available = false;
			    var ip = '-';
			    var netmask = '-';
                
                if (result[0] === 0 && result[1].code === 0) { 
					var wlanIndex = result[1].stdout.indexOf('wlan0');
					if (wlanIndex > 0) {
					    available = true;
					    var startIndex = result[1].stdout.indexOf('inet addr:', wlanIndex);
					    var endIndex = result[1].stdout.indexOf('  Bcast', startIndex);
					    ip = result[1].stdout.substring(startIndex + 'inet addr:'.length, endIndex);
					    startIndex = result[1].stdout.lastIndexOf('Mask:');
					    endIndex = result[1].stdout.indexOf('\n', startIndex);
					    netmask = result[1].stdout.substring(startIndex + 'Mask:'.length, endIndex);
					    console.log('Available[' + available + '] IP[' + ip + '] Netmask[' + netmask + ']');
					} else {
					    console.log('Failed to retrieve IP address information!');
					}
			    } else {
					console.log('Failed to execute IP address command!');
			    }
			    
			    ipResult([{available: available}, {ip: ip}, {netmask: netmask}]);
			};
			
			/*
			var update = function () {
				params = {};
				self.ubus.request('network.device', 'status', params, function (result) {
					console.log(result);
				});
			};

			var setToken = function (result) {

				var returnCode = result[0];

				if (returnCode === 0) { 
					var token = result[1].ubus_rpc_session;

	                console.log('session token: ' + token);
					if (typeof(Storage) !== 'undefined') {
						localStorage.setItem('token', token);
						localStorage.setItem('alive', true);
					    startHeartbeat(10000);
					}

					settionProvider.ubus.token = token;
					console.log(settionProvider.ubus);

					loginReturn({success: true});

				} else {
				    console.log('Login failed!');

				    loginReturn({success: false});
				}
			};
			*/

			Polymer({
				is: 'onion-device-provider',
				created: created,
				ready: ready,
				//update: update,
				noop: function () {},
				ready: ready,
				getMAC: getMAC,
				getSystem: getSystem,
				setMACResult: setMACResult,
				getRxTx: getRxTx,
				setRxTxResult: setRxTxResult,
				getIP: getIP,
				setIPResult: setIPResult,
			});
        })();
	</script>
</dom-module>
